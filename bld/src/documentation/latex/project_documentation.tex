% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[a4paper,11pt,english]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}

\addto\captionsenglish{\renewcommand{\figurename}{Fig. }}
\addto\captionsenglish{\renewcommand{\tablename}{Table }}
\floatname{literal-block}{Listing }



\title{Documentation of the The Swiss case: Reactions of the real economy to the discontinuation of the exchange rate floor in 2015. A synthetic control approach project}
\date{16 March 2018}
\release{}
\author{Martin Dohmen}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@ch\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@cpf\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@mb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\renewcommand\PYGZsq{\textquotesingle}

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}



\chapter{Introduction}
\label{introduction:introduction}\label{introduction:id1}\label{introduction:welcome-to-the-project-s-documentation-of-the-swiss-case-reactions-of-the-real-economy-to-the-discontinuation-of-the-exchange-rate-floor-in-2015-a-synthetic-control-approach}\label{introduction::doc}
This project estimates the real consequences of the Swiss appreciation from January 2015 using the synthetic control method. The idea is to construct a synthetic Switzerland
as a control unit, which describes how Switzerland would have developed in absence of a large appreciation. The difference in development after the decision of the SNB to unpeg the franc
between the actual and the synthetic Switzerland is the treatment effect.

The method is based on Abadie et al. (2010, 2014). \phantomsection\label{introduction:id2}{\hyperref[references:abadie2010]{\emph{{[}1{]}}}} \phantomsection\label{introduction:id3}{\hyperref[references:abadie2014]{\emph{{[}2{]}}}}
On the basis of pre-treatment data a weighted average of control countries is constructed to work as a synthetic control for the treated country.
The method is described shortly below.

The algorithm used to calculate the synthetic control is based on Becker and Klößner (2018) \phantomsection\label{introduction:id4}{\hyperref[references:becker2018]{\emph{{[}3{]}}}}.
The implementation and algorithm suggested by them is explained briefly below.

The project is based on the Templates for Reproducible Research Projects in Economics by von Gaudecker. \phantomsection\label{introduction:id5}{\hyperref[references:gaudeckereconprojecttemplates]{\emph{{[}4{]}}}}


\section{Structure}
\label{introduction:structure}
The project is structured in different folders. Every folder contains files with dictinct functions.
The folders are:
\begin{quote}
\begin{itemize}
\item {} 
original\_data

\item {} 
data\_management

\item {} 
analysis

\item {} 
final

\item {} 
paper

\item {} 
model\_code

\item {} 
model\_specs

\end{itemize}

Following the folders, the project is organised in different steps:
\begin{enumerate}
\item {} 
data management: take the raw data from \textbf{original\_data} and clean it and bring it in the structure we need (second normal form)

\item {} 
analysis: Taking the functions defining the ``model'', in my case implementing the algorithm of Becker and Klößner (2018) \phantomsection\label{introduction:id6}{\hyperref[references:becker2018]{\emph{{[}3{]}}}} from \textbf{model\_code}, and the specifications defined for the models in \textbf{model\_specs}, the main analysis is done. The synthetic control unit and all necessary values are calculated and the results are stored.

\item {} 
final: In this step the results from the analysis step are visualised. This means tables and figures are constructed.

\item {} 
paper: This is the last step. Figures and tables are incorporated and the paper is compiled.

\end{enumerate}
\end{quote}

Detailed discribtions of what exactly every step and file is doing can be found in the following chapters.

The project runs 6 different specifications contained in \textbf{model\_specs}. These are:
\begin{enumerate}
\item {} 
a baseline specification for GDPPC: outcome is GDPPC and predictors are yearly averages of the outcome for 2008, 2010, 2012, 2013, 2014

\item {} 
a all-year averages specification for GDPPC: outcome is GDPPC and predictors are yearly averages of the outcome for 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014

\item {} 
a with-covariates specification: outcome is GDPPC and predictors are an averages of the outcome for 2012, 2013, 2014 and other covariates: trade opennes, inflation, industry share and schooling

\item {} 
a current-account specification: outcome is CA as \% of GDP and predictors are an averages of the outcome for 2012, 2013, 2014 and other covariates: trade opennes, inflation, industry share and schooling

\item {} 
a time placebo specification: as baseline, but treatment time changes to 2005Q1 and accordingly sample period and predictor years are ten years earlier

\item {} 
a country-placebo specification: as baseline, but treated country changes to Australia and Switzerland is excluded

\end{enumerate}

For every specification the analysis is run and tables and figures are produced.


\section{The Synthetic Control Method}
\label{introduction:the-synthetic-control-method}
In this section I want to give a short description of the synthetic control method. It follows mainly Abadie (2010) \phantomsection\label{introduction:id7}{\hyperref[references:abadie2010]{\emph{{[}1{]}}}} . For details please refer to this paper and the ones cited above.

The synthetic control method is a data-driven approach to construct a suitable control unit in comparative case studies. The idea is that a combination of control units will often provide a better comparison for the treated unit than a single control unit alone. Therefore, the synthetic control is constructed as a weighted average of so called donors, a sample of suitable control units, with non-negative weights that sum to one. These weights, collected in a vector \emph{W}, are calculated by minimizing the difference of selected predictor variables between the treated unit and the synthetic control. The predictor variables can be linear combinations of the outcome variable prior to treatment as well as other covariates with explanatory power for the outcome of interest, which need to be measured prior to or unaffected by the treatment. In the optimization the predictors are weighted by a predictor weighting matrix \emph{V}, which is chosen to result in optimal weights \emph{W} that yield the lowest possible RMSPE between the outcome of the treated unit and the synthetic control prior to treatment. This structure leads to a nested optimization problem. In the inner optimization the optimal donor weights \emph{W} are determined, which construct the synthetic control unit. These optimization depends on the predictor weights \emph{V}, which are determined in the outer optimization to guarantee the best possible pre-treatment fit. The resulting optimal weights define the synthetic control unit. The treatment effect consists of the difference in the outcome variable after treatment between the treated unit and the synthetic control.


\section{The Implementation and  the Algorithm}
\label{introduction:the-implementation-and-the-algorithm}
The structure of the synthetic control method described above poses some challenges to the implementation. The problem is that the nested optimization is not only computational intensive and therefore slow with larger data sets, but it might also be quite unstable and unreliable with numerical optimizers. The reason for that is that the objective function of the outer optimization contains a minimization problem, which results in a noisy function that might be ill behaved and can fool the outer optimizer. Becker and Klößner (2018) \phantomsection\label{introduction:id8}{\hyperref[references:becker2018]{\emph{{[}3{]}}}} provide an algorithm that tries to reduce these problems. It starts with detecting important special cases that are easy to compute and then tries to reduce the dimension of the nested optimization problem.

The basis of Becker and Klößner's argumentation consists of some theory concerning the optimization problems that have to be solved for applying the synthetic control method. They start with separating the donor pool in sunny and shady donors. A shady donor is a control unit, whose difference in predictor values to the treated unit multiplied by \(\alpha\) with \(0<\alpha<1\) lies inside the convex hull of the differences of all donor units. They show that if a donor is shady, it will not be part of an optimal synthetic control unit. Furthermore, they give simple solutions in cases with no sunny donors, which means exact fit is possible, or only one sunny donor, which will then be the unique donor with positive weight. If none of these special cases occur, the algorithm tests whether the unrestricted outer optimum is feasible. This means it searches for predictor weights \emph{V} which result in donor weights \emph{W} that constitute the global minimum of the outer optimization problem. Only if finding such predictor weights is not possible, the nested optimization is performed. In order to do this, the dimension of the problem is reduced by excluding all shady donors. A detailed description of the algorithm can be found in Becker and Klößner (2018) \phantomsection\label{introduction:id9}{\hyperref[references:becker2018]{\emph{{[}3{]}}}} and Figure 2 in their paper illustrate it's structure in a simple way.


\section{Testing}
\label{introduction:testing}
I do different forms of testing:

For the functions defined in the model code that construct the algorithm explained in the last section I do unit and integration tests using pytest. For the function
putting everything together I do system tests.
These tests confirm that I implemented all formulas from Becker and Klößner correctly.

All data work was firstly done and tested using Jupyter notebooks.

Furtherore, as a kind of regression testing, I compared some results to the implementation of the synthetic control method in stata (the synth package by Abadie et al. (2010) \phantomsection\label{introduction:id10}{\hyperref[references:abadie2010]{\emph{{[}1{]}}}})
for one specification and the results are similar.


\chapter{Original data}
\label{original_data:id1}\label{original_data:original-data}\label{original_data::doc}
This section stores the raw data, which you should not manipulate to ensure reproducibility.

Documentation of the different datasets in \emph{original\_data}:

\code{Current\_account\_percentage\_GDP\_OECD\_quarterly\_1990\_2017.csv} : A dataset from OECD.Stat containing quarterly data on current account in \% of GDP from 1990 to 2017 for all OECD countries.

\code{GDPPC\_OECD\_1990\_2017.csv} : A dataset from the quarterly national accounts in OECD.Stat containing quarterly GDP per capita data from 1990 to 2017 for all OECD countries.

\code{predictor\_data\_WDI.csv} : A dataset containing data for the covariates used as predictors (trade opennes, inflation, industry share and schooling) for all OECD data from 2010 to 2015.


\chapter{Data management}
\label{data_management:id1}\label{data_management:data-management}\label{data_management::doc}
This section does include all code doing the data management. This means it cleans the data, replaces missing values and brings it in the second normal form.
Only the data needed for the later analysis is extracted.

The second normal form is violated in one case, namely in the created table containing the predictor variables. In this table also the country names are included.
This is done to make the data easier to read for humans in between, which was necessary in some stages of the project. As the dataset is only small, in my opinion the violation is not that much of a concern.

The data management is done in the file \code{clean\_raw\_data.py} in the folder \emph{src.data\_management}.

It does and contains:
\phantomsection\label{data_management:module-src.data_management.clean_raw_data}\index{src.data\_management.clean\_raw\_data (module)}
Clean the raw data to use it for the analysis and bring it in the second normal
form: Create a table for countries with IDs, one for time periods with IDs and
one for every data series we do have and use later on. Furthermore, clean and
replace missings for predictors and calculate averages for predictors over the 
years 2012-2014 and safe them in a seperate datafile.

All tested using Jupyter notebook and regression tests.
\index{create\_ca\_percentage\_gdp\_table() (in module src.data\_management.clean\_raw\_data)}

\begin{fulllineitems}
\phantomsection\label{data_management:src.data_management.clean_raw_data.create_ca_percentage_gdp_table}\pysiglinewithargsret{\bfcode{create\_ca\_percentage\_gdp\_table}}{\emph{data}, \emph{countries}, \emph{periods}}{}
Create table of current accout in percentage of GDP for every country
only including country ID and period ID.

\end{fulllineitems}

\index{create\_country\_table() (in module src.data\_management.clean\_raw\_data)}

\begin{fulllineitems}
\phantomsection\label{data_management:src.data_management.clean_raw_data.create_country_table}\pysiglinewithargsret{\bfcode{create\_country\_table}}{\emph{data}}{}
Create table of countries sorted alphabetically with new IDs.

\end{fulllineitems}

\index{create\_gdppc\_const\_prices\_table() (in module src.data\_management.clean\_raw\_data)}

\begin{fulllineitems}
\phantomsection\label{data_management:src.data_management.clean_raw_data.create_gdppc_const_prices_table}\pysiglinewithargsret{\bfcode{create\_gdppc\_const\_prices\_table}}{\emph{data}, \emph{countries}, \emph{periods}}{}
Create table of GDPPC in constant prices (OECD reference year)
with fixed PPP for every country only including
country ID and period ID.

\end{fulllineitems}

\index{create\_gdppc\_current\_prices\_table() (in module src.data\_management.clean\_raw\_data)}

\begin{fulllineitems}
\phantomsection\label{data_management:src.data_management.clean_raw_data.create_gdppc_current_prices_table}\pysiglinewithargsret{\bfcode{create\_gdppc\_current\_prices\_table}}{\emph{data}, \emph{countries}, \emph{periods}}{}
Create table of GDPPC in current prices with current PPP for every country
only including country ID and period ID.

\end{fulllineitems}

\index{create\_period\_table() (in module src.data\_management.clean\_raw\_data)}

\begin{fulllineitems}
\phantomsection\label{data_management:src.data_management.clean_raw_data.create_period_table}\pysiglinewithargsret{\bfcode{create\_period\_table}}{\emph{data}}{}
Create table of Periods with IDs.

\end{fulllineitems}

\index{create\_table\_of\_predictors() (in module src.data\_management.clean\_raw\_data)}

\begin{fulllineitems}
\phantomsection\label{data_management:src.data_management.clean_raw_data.create_table_of_predictors}\pysiglinewithargsret{\bfcode{create\_table\_of\_predictors}}{\emph{country\_table}, \emph{predictor\_variables}}{}
Create the table of predictor variables for every country only including
country id and the different predictors.

\end{fulllineitems}

\index{read\_in\_data() (in module src.data\_management.clean\_raw\_data)}

\begin{fulllineitems}
\phantomsection\label{data_management:src.data_management.clean_raw_data.read_in_data}\pysiglinewithargsret{\bfcode{read\_in\_data}}{\emph{filename}}{}
Read in source data.

\end{fulllineitems}



\chapter{Main model estimations / simulations}
\label{analysis:main-model-estimations-simulations}\label{analysis:analysis}\label{analysis::doc}
In this section the main analysis is done. This means the code computes the synthetic control unit and all relevant values for every model.
To do so it defines numpy matrices from the data and calculate x\_tilde and z\_tilde which are needed as inputs for the algorithm used for the model code.
Then it calls the main function from the \emph{model\_code}, \textbf{determine\_synthetic\_control\_weights}, to calculate the synthetic control. Afterwards, the data is formated as needed
for plots and graphs and all results are saved in pickle file as a dictionary.

All this is done in the file \code{synthetic\_control.py} in the folder \emph{src.analysis}.

It does and contains:
\phantomsection\label{analysis:module-src.analysis.synthetic_control}\index{src.analysis.synthetic\_control (module)}
Run the synthetic control method to define the weights for a synthetic
Switzerland.

All developed and tested using Jupyter notebooks.
\index{get\_x\_one\_and\_x\_zero\_from\_data() (in module src.analysis.synthetic\_control)}

\begin{fulllineitems}
\phantomsection\label{analysis:src.analysis.synthetic_control.get_x_one_and_x_zero_from_data}\pysiglinewithargsret{\bfcode{get\_x\_one\_and\_x\_zero\_from\_data}}{\emph{dep\_variable}, \emph{predictor\_data}, \emph{predictors}, \emph{index\_treated}, \emph{index\_donors}}{}
Extraxt X\_1 and x\_0, the matrices of predictor values for treated unit
and donors from the data. Build up matrices recursivly looping over
predictor definitions.

\end{fulllineitems}

\index{get\_x\_tilde() (in module src.analysis.synthetic\_control)}

\begin{fulllineitems}
\phantomsection\label{analysis:src.analysis.synthetic_control.get_x_tilde}\pysiglinewithargsret{\bfcode{get\_x\_tilde}}{\emph{dep\_variable}, \emph{predictor\_data}, \emph{predictors}, \emph{index\_treated}, \emph{index\_donors}}{}
Calculate X\_tilde = X\_0 - X\_1 * vector\_ones', the input data for the
inner minimization of the synthetic control method.

\end{fulllineitems}

\index{get\_z\_one\_from\_data() (in module src.analysis.synthetic\_control)}

\begin{fulllineitems}
\phantomsection\label{analysis:src.analysis.synthetic_control.get_z_one_from_data}\pysiglinewithargsret{\bfcode{get\_z\_one\_from\_data}}{\emph{dep\_variable}, \emph{index\_treated}, \emph{index\_pre\_treatment\_start}, \emph{index\_treatment\_start}}{}
Calculate the array Z\_one, the array of pre-treatment data of the
dependent variable for the treated unit.

\end{fulllineitems}

\index{get\_z\_tilde() (in module src.analysis.synthetic\_control)}

\begin{fulllineitems}
\phantomsection\label{analysis:src.analysis.synthetic_control.get_z_tilde}\pysiglinewithargsret{\bfcode{get\_z\_tilde}}{\emph{dep\_variable}, \emph{index\_treated}, \emph{index\_donors}, \emph{index\_pre\_treatment\_start}, \emph{index\_treatment\_start}}{}
Calculate Z\_tilde = Z\_0 - Z\_1 * vector\_ones', the input data for the
outer minimization of the synthetic control method.

\end{fulllineitems}

\index{get\_z\_zero\_from\_data() (in module src.analysis.synthetic\_control)}

\begin{fulllineitems}
\phantomsection\label{analysis:src.analysis.synthetic_control.get_z_zero_from_data}\pysiglinewithargsret{\bfcode{get\_z\_zero\_from\_data}}{\emph{dep\_variable}, \emph{index\_donors}, \emph{index\_pre\_treatment\_start}, \emph{index\_treatment\_start}}{}
Calculate the array Z\_one, the array of pre-treatment data of the
dependent variable for the treated unit.

\end{fulllineitems}

\index{standarize\_data() (in module src.analysis.synthetic\_control)}

\begin{fulllineitems}
\phantomsection\label{analysis:src.analysis.synthetic_control.standarize_data}\pysiglinewithargsret{\bfcode{standarize\_data}}{\emph{data}}{}
Standarize data to have mean zero and unit variance.

\end{fulllineitems}



\chapter{Visualisation and results formatting}
\label{final:visualisation-and-results-formatting}\label{final:final}\label{final::doc}
In this section the tables and figures are constructed from the results contained in the pickle file saved in the main analysis.
The code is located in the directory \emph{src.final}.


\section{Tables}
\label{final:tables}
For every specification the file \code{sc\_tables.py} construct three tables:
\begin{enumerate}
\item {} 
a table containing the weights for the countries in the donor pool constituting the synthetic control.

\item {} 
a table containing the predictors for the treated country and the synthetic control.

\item {} 
a table containing the outcomes for the treated country and the synthetic control as well as the constraint weighting matrix V and the status of the optimization. (This table is constructed just for inspection and to calculate some values for the paper, but is not included in the paper)

\end{enumerate}


\section{Figures}
\label{final:figures}
Furthermore, for every specification the file \code{plot\_sc\_graph.py} construct a figure showing the development of the outcome variable for the treated unit and the synthetic control.
To do so it defines and uses to functions.

The file does and contains:
\phantomsection\label{final:module-src.final.plot_sc_graph}\index{src.final.plot\_sc\_graph (module)}
Plot the graph describing the solution of the synthetic control method.
This means plot a line graph with time on x-achsis and the dependent variable
on y-achsis and lines for the treated unit and the synthetic control.
\index{get\_dates\_for\_x\_axsis() (in module src.final.plot\_sc\_graph)}

\begin{fulllineitems}
\phantomsection\label{final:src.final.plot_sc_graph.get_dates_for_x_axsis}\pysiglinewithargsret{\bfcode{get\_dates\_for\_x\_axsis}}{\emph{start\_year}, \emph{end\_year}, \emph{start\_quarter=1}, \emph{end\_quarter=1}}{}
Prepare the dates on the x-axis of the plot.

\end{fulllineitems}

\index{plot\_dep\_var() (in module src.final.plot\_sc\_graph)}

\begin{fulllineitems}
\phantomsection\label{final:src.final.plot_sc_graph.plot_dep_var}\pysiglinewithargsret{\bfcode{plot\_dep\_var}}{\emph{z\_one}, \emph{z\_sc}, \emph{model\_name}, \emph{start\_date}, \emph{end\_date}, \emph{name}, \emph{treatment\_date}}{}
Create a line graph of the dependent variable for the treated unit and
the synthetic control unit with time on x-axis.

\end{fulllineitems}



\chapter{Research paper / presentations}
\label{paper:research-paper-presentations}\label{paper:paper}\label{paper::doc}
The file: \code{research\_paper.tex} contains the actual paper. This includes all text as well as the latex code to include figures and tables.

It is located in the directory \emph{src.paper}.

Furthermore the directory contains the references cited in the paper in \code{refs.bib} and an image which is included as a figure in the paper as well.


\chapter{Model code}
\label{model_code:id1}\label{model_code:model-code}\label{model_code::doc}
This section contains a collection of functions implementing the algorithm by Becker and Klößner (2018). \phantomsection\label{model_code:id2}{\hyperref[references:becker2018]{\emph{{[}3{]}}}}

This is done in the file \code{synth\_control\_functions.py} in the folder \emph{src.model\_code}:

The file contains:
\phantomsection\label{model_code:module-src.model_code.synth_control_functions}\index{src.model\_code.synth\_control\_functions (module)}
Provide functions to calculate optimal weights for synthetic control unit.
\index{calculate\_inner\_part\_of\_inequ\_constr\_for\_linprog\_16() (in module src.model\_code.synth\_control\_functions)}

\begin{fulllineitems}
\phantomsection\label{model_code:src.model_code.synth_control_functions.calculate_inner_part_of_inequ_constr_for_linprog_16}\pysiglinewithargsret{\bfcode{calculate\_inner\_part\_of\_inequ\_constr\_for\_linprog\_16}}{\emph{x\_tilde}, \emph{w\_outer}}{}
Calculate the inner part of the inequality constraints for the linear +
program in (20) from Becker and Klößner (2018). This is, calculate
(e\_j - v) ` B\_k  w for k=1,...,K and stack them into a vector. Do that for
all countries J, so j = 1,..., J and stack them into a matrix to get the
matrix defining the inequality constraint of the linear program A\_ub.

\end{fulllineitems}

\index{create\_matrix\_v\_from\_v\_k\_tilde() (in module src.model\_code.synth\_control\_functions)}

\begin{fulllineitems}
\phantomsection\label{model_code:src.model_code.synth_control_functions.create_matrix_v_from_v_k_tilde}\pysiglinewithargsret{\bfcode{create\_matrix\_v\_from\_v\_k\_tilde}}{\emph{v\_k\_tilde}, \emph{k}}{}
Create matrix V from v\_k\_tilde about which to optimize, see (20)
in Becker and Klößner (2018).

\end{fulllineitems}

\index{determine\_synthetic\_control\_weights() (in module src.model\_code.synth\_control\_functions)}

\begin{fulllineitems}
\phantomsection\label{model_code:src.model_code.synth_control_functions.determine_synthetic_control_weights}\pysiglinewithargsret{\bfcode{determine\_synthetic\_control\_weights}}{\emph{x\_tilde}, \emph{z\_tilde}, \emph{lower\_bound=1e-08}}{}
Put everything together to determine the
optimal country weights w and the optimal constraint weighting matrix v
defining the synthetic control. As inputs use only numpy matrixes!
The function works as described in the paper by Becker and Klößner (2018),
especially it uses the algorithm shown in figure 2 of the paper. The
difference to the paper so far is that it does not allow to pass a mapping
V, but builds up V as a diagonal matrix of constraint weights. This means,
so far it does not allow for time series as constraints with stable weights
for the whole time series. Instead it always calculates for every single
constraint the optimal weight to solve the outer minimization problem.
This means do:
\begin{quote}
\begin{enumerate}
\item {} 
determine sunny donors

\end{enumerate}

2. test of no sunny donors, if so solve outer minimization constraint
to exact fit and stop.

3. test of one sunny donor, if so just give him a positive weight
and stop.

4. try if unrestricted outer minimization feasible, if so choose
weights solving unrestricted outer minimization and stop.
\begin{enumerate}
\setcounter{enumi}{4}
\item {} 
Perform the nested optimization task and choose weights solving it.

\end{enumerate}
\end{quote}

\end{fulllineitems}

\index{determine\_unrestricted\_outer\_optimum() (in module src.model\_code.synth\_control\_functions)}

\begin{fulllineitems}
\phantomsection\label{model_code:src.model_code.synth_control_functions.determine_unrestricted_outer_optimum}\pysiglinewithargsret{\bfcode{determine\_unrestricted\_outer\_optimum}}{\emph{z\_tilde}}{}
Solve euqtion (13) in Becker and Klößner (2018) to get weights solving
the unrestricted outer optimization problem. Return these weights.

\end{fulllineitems}

\index{find\_sunny\_donors() (in module src.model\_code.synth\_control\_functions)}

\begin{fulllineitems}
\phantomsection\label{model_code:src.model_code.synth_control_functions.find_sunny_donors}\pysiglinewithargsret{\bfcode{find\_sunny\_donors}}{\emph{x\_tilde}}{}
Find sunny donors from a numpy array of all donors according to (9)
in Becker and Klößner (2018). Return a numpy array only including the data
remaining for sunny donors and the number of sunny donors.
Additionaly return the index in the matrix of columns for sunny and shady
donors.

\end{fulllineitems}

\index{function\_to\_solve\_for\_outer\_optimum() (in module src.model\_code.synth\_control\_functions)}

\begin{fulllineitems}
\phantomsection\label{model_code:src.model_code.synth_control_functions.function_to_solve_for_outer_optimum}\pysiglinewithargsret{\bfcode{function\_to\_solve\_for\_outer\_optimum}}{\emph{w}, \emph{z\_tilde}}{}
Function to solve for the outer optimum as used in (7) or (13) of
Becker and Klößner (2018).

\end{fulllineitems}

\index{inner\_optimization() (in module src.model\_code.synth\_control\_functions)}

\begin{fulllineitems}
\phantomsection\label{model_code:src.model_code.synth_control_functions.inner_optimization}\pysiglinewithargsret{\bfcode{inner\_optimization}}{\emph{x\_tilde}, \emph{v}}{}
Perform the inner optimization of the synthetic control problem,
corresponding to equation (8) in Becker and Klößner (2018).
Return optimal weights for countries w.

\end{fulllineitems}

\index{inner\_optimization\_function() (in module src.model\_code.synth\_control\_functions)}

\begin{fulllineitems}
\phantomsection\label{model_code:src.model_code.synth_control_functions.inner_optimization_function}\pysiglinewithargsret{\bfcode{inner\_optimization\_function}}{\emph{w}, \emph{x\_tilde}, \emph{v}}{}
Construct the function to minimize by the inner optimization, 
corresponding to the part after min in (8) in Becker and Klößner (2018)

\end{fulllineitems}

\index{outer\_optimization() (in module src.model\_code.synth\_control\_functions)}

\begin{fulllineitems}
\phantomsection\label{model_code:src.model_code.synth_control_functions.outer_optimization}\pysiglinewithargsret{\bfcode{outer\_optimization}}{\emph{z\_tilde}, \emph{x\_tilde}, \emph{lower\_bound=1e-08}}{}
Perform the outer optimization of equation (7) in Becker and klößner
(2018). Use K optimizations of dimension K-1 as described in the paper
in 3.5.. Return the optimal constrains weighting matrix v.

\end{fulllineitems}

\index{outer\_optimization\_function() (in module src.model\_code.synth\_control\_functions)}

\begin{fulllineitems}
\phantomsection\label{model_code:src.model_code.synth_control_functions.outer_optimization_function}\pysiglinewithargsret{\bfcode{outer\_optimization\_function}}{\emph{v\_k\_tilde}, \emph{z\_tilde}, \emph{x\_tilde}, \emph{k}, \emph{K}}{}
Construct the function to minimize in the K subproblems of the outer
optimization. For that consruct V according to (20) and than construct
function used in (7) in Becker and klößner (2018).

\end{fulllineitems}

\index{solve\_case\_of\_no\_sunny\_donors() (in module src.model\_code.synth\_control\_functions)}

\begin{fulllineitems}
\phantomsection\label{model_code:src.model_code.synth_control_functions.solve_case_of_no_sunny_donors}\pysiglinewithargsret{\bfcode{solve\_case\_of\_no\_sunny\_donors}}{\emph{x\_tilde}}{}
Solve the case when we have no sunny donors, so a perfect fit of the
treated unit is possible. In this case I deviate from the paper by
Becker and Klößner (2018). In their paper they solve the linear programm
(10). This does not work with scipy.optimize as the minimizer does not
support problems with more equality constraints than independent variables.
As I did not find a good optimizer for python so far solving this problem,
I will just choose a weights solving the inner minimization, so leading to
a perfect fit for the synthetic control unit regarding the predictor
variables. This might not be optimal concerning the outer optimization!
The reason for this shortcut is that the case of perfect fit is very
unprobable to begin with. If this case happens, the program will print a
warning. In this case a good solution would be to choose more predictor
variables. In an extrem case all variables/data points defining the outer
optimization can be used as predictors. This would lead to the problem being
unimportant as outer and inner optimization become the same!

\end{fulllineitems}

\index{ten\_to\_the\_power\_of\_x() (in module src.model\_code.synth\_control\_functions)}

\begin{fulllineitems}
\phantomsection\label{model_code:src.model_code.synth_control_functions.ten_to_the_power_of_x}\pysiglinewithargsret{\bfcode{ten\_to\_the\_power\_of\_x}}{\emph{x}}{}
Calculate 10 to the power of x.

\end{fulllineitems}

\index{try\_if\_unrestricted\_outer\_optimum\_feasible() (in module src.model\_code.synth\_control\_functions)}

\begin{fulllineitems}
\phantomsection\label{model_code:src.model_code.synth_control_functions.try_if_unrestricted_outer_optimum_feasible}\pysiglinewithargsret{\bfcode{try\_if\_unrestricted\_outer\_optimum\_feasible}}{\emph{x\_tilde}, \emph{z\_tilde}, \emph{lower\_bound=1e-08}}{}
Solve linear program in (16) in Becker and Klößner (2018).
This means, determine if the outer optimum is feasible.
If so, return a status telling that and the weights forming the outer
optimum as well as the normalized constraint weighting matrix V belonging
to the outer optimum. If not, return a status telling the outer optimum is
infeasible and give numpy.nan as weights w and V.

\end{fulllineitems}


All functions are tested using pytest within the file \code{synth\_control\_functions\_test.py}!


\chapter{Model specifications}
\label{model_specs:model-specifications}\label{model_specs:id1}\label{model_specs::doc}
The directory \emph{src.model\_specs} contains \href{http://www.json.org/}{JSON} files with model specifications.
These files define the different model specifications used to calculate synthetic controls for different szenarios.

You can input the treatment country, the treatment date, the period you are considering, the donor pool, the outcome variable and all predictor variables.

Thereby everything except the predictor variables are defined in the files named synth\_control\_parameters\_*specification\_name*, and the predictors in predictors\_*specification\_name*. In the later one also the names of the predictors to input in the table are defined.
It is important that for every specification both are specified.

These specifications are, as explained in the introduction:
\begin{enumerate}
\item {} 
a baseline specification for GDPPC: outcome is GDPPC and predictors are yearly averages of the outcome for 2008, 2010, 2012, 2013, 2014

\item {} 
a all-year averages specification for GDPPC: outcome is GDPPC and predictors are yearly averages of the outcome for 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014

\item {} 
a with-covariates specification: outcome is GDPPC and predictors are an averages of the outcome for 2012, 2013, 2014 and other covariates: trade opennes, inflation, industry share and schooling

\item {} 
a current-account specification: outcome is CA as \% of GDP and predictors are an averages of the outcome for 2012, 2013, 2014 and other covariates: trade opennes, inflation, industry share and schooling

\item {} 
a time placebo specification: as baseline, but treatment time changes to 2005Q1 and accordingly sample period and predictor years are ten years earlier

\item {} 
a country-placebo specification: as baseline, but treated country changes to Australia and Switzerland is excluded

\end{enumerate}


\chapter{References}
\label{references:references}\label{references:id1}\label{references::doc}


\begin{thebibliography}{1}
\bibitem[1]{1}{\phantomsection\label{references:abadie2010} 
Alberto Abadie, Alexis Diamond, and Jens Hainmueller. Synthetic control methods for comparative case studies: estimating the effect of california’s tobacco control program. \emph{Journal of the American Statistical Association}, 105(490):493–505, 2010. URL: \href{https://doi.org/10.1198/jasa.2009.ap08746}{https://doi.org/10.1198/jasa.2009.ap08746}, \href{https://arxiv.org/abs/https://doi.org/10.1198/jasa.2009.ap08746}{arXiv:https://doi.org/10.1198/jasa.2009.ap08746}, \href{https://doi.org/10.1198/jasa.2009.ap08746}{doi:10.1198/jasa.2009.ap08746}.
}
\bibitem[2]{2}{\phantomsection\label{references:abadie2014} 
Alberto Abadie, Alexis Diamond, and Jens Hainmueller. Comparative politics and the synthetic control method. \emph{American Journal of Political Science}, 59(2):495–510, apr 2014. \href{https://doi.org/10.1111/ajps.12116}{doi:10.1111/ajps.12116}.
}
\bibitem[3]{3}{\phantomsection\label{references:becker2018} 
Martin Becker and Stefan Klößner. Fast and reliable computation of generalized synthetic controls. \emph{Econometrics and Statistics}, 5:1–19, jan 2018. \href{https://doi.org/10.1016/j.ecosta.2017.08.002}{doi:10.1016/j.ecosta.2017.08.002}.
}
\bibitem[4]{4}{\phantomsection\label{references:gaudeckereconprojecttemplates} 
Hans-Martin von Gaudecker. Templates for reproducible research projects in economics. \DUspan{}{}https://github.com/hmgaudecker/econ-project-templates, 2014.
}
\end{thebibliography}


\renewcommand{\indexname}{Python Module Index}
\begin{theindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{a}
\item {\texttt{src.analysis.synthetic\_control}}, \pageref{analysis:module-src.analysis.synthetic_control}
\indexspace
\bigletter{d}
\item {\texttt{src.data\_management.clean\_raw\_data}}, \pageref{data_management:module-src.data_management.clean_raw_data}
\indexspace
\bigletter{f}
\item {\texttt{src.final.plot\_sc\_graph}}, \pageref{final:module-src.final.plot_sc_graph}
\indexspace
\bigletter{m}
\item {\texttt{src.model\_code.synth\_control\_functions}}, \pageref{model_code:module-src.model_code.synth_control_functions}
\end{theindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}
